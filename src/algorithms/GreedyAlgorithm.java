package algorithms;

public class GreedyAlgorithm {
////////////////////////////////////活动选择问题////////////////////////////////////////
//假定有个一n个活动的集合S={a1,a2,...,an}，这些活动使用同一个资源（例如一个阶梯教室），而这个资源在某个
//时刻只能供一个活动使用。每个活动ai都有一个开始时间si和一个结束时间fi。如果被选中，任务ai发生在半开时间区间
//[si,fi)期间。如果两个活动ai和aj满足[si,fi)和[sj,fj)不重叠，则称它们是兼容的。也就是说，若si>=sj，fi>=fj，
//则ai和aj是兼容的。在活动选择问题中，我们希望选出一个最大兼容集合。假定活动已按结束时间 的单调递增顺序排序

//  i   1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11
//  ——————————————————————————————————————————————
//  si  1 | 3 | 0 | 5 | 3 | 5 | 6 | 8 | 8 | 2 | 12
//  ——————————————————————————————————————————————
//  fi  4 | 5 | 6 | 7 | 9 | 9 | 10| 11| 12| 14| 16
//
//贪心选择
//对于活动选择问题，什么是贪心选择？直观上，我们应该选择这样一个活动，选出它后剩下的资源应能被尽量多的其他任务所用。
//现在考虑可选的活动，其中必然有一个最先结束。因此，直觉告诉我们，应该选择S中最早结束的活动，因为它剩下的资源可供它之后
//尽量多的活动使用。（如果S中最早结束的活动有多个，我们可以选择其中任意一个）。换句话说，由于活动已按结束时间单调递增的
//顺序排序，贪心选择就是活动a1。
//令Sk为在ak结束后开始的任务集合。当我们做出贪心选择，选择了a1后，剩下的S1是唯一需要求解的子问题。如果a1在最优解中，
//那么原问题的最优解由活动a1及子问题S1中所有活动组成
//
//贪心算法通常是自顶向下的设计，做出一个选择，然后求解剩下的那个子问题，而不是自底向上第求解很多子问题，然后再做出选择。
//
//递归贪心算法O(n)
//RECURSIVE-ACTIVITY-SELECTOR(s,f,k,n)
//1 m=k+1
//2 while m<=n and s[m]<f[k]               //find the first activity in Sk to finish
//3    m=m+1
//4 if m<=n
//5    return {am}并RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)
//6 else return 空集

//为了方便算法初始化，我们添加一个虚拟活动a0，其结束时间f0=0，这样子问题S0就是完整的活动集S。求解原问题即可
//调用RECURSIVE-ACTIVITY-SELECTOR(s,f,0,n)
//
//迭代贪心算法O(n)
//GREEDY-ACTIVITY-SELECTOR(s,f)
//1 n=s.length
//2 A={a1}
//3 k=1
//4 for m=2 to n
//5    if s[m]>=f[k]
//6       A=A并{am}
//7       k=m
//8 return A
}
